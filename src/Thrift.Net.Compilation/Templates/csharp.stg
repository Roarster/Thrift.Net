document(version, model, typeMap) ::= <<
// <auto-generated>
// This file was generated by Thrift.Net version $version$. Do not edit this file
// directly - any changes may be lost.
// </auto-generated>
$if(model.CSharpNamespace)$
namespace $model.CSharpNamespace$
{
    $generateDocument(model, typeMap)$
}
$else$
$generateDocument(model, typeMap)$
$endif$
>>

generateDocument(model, typeMap) ::= <<
using System.Threading;
using System.Threading.Tasks;

using Thrift.Protocol;
using Thrift.Protocol.Entities;
using Thrift.Protocol.Utilities;
$if(model.Enums)$

$model.Enums:generateEnum(); separator="\n\n"$
$endif$
$if(model.Structs)$

$model.Structs:{struct | $generateStruct(struct, typeMap)$}; separator="\n\n"$
$endif$
>>

generateEnum(enum) ::= <<
public enum $enum.Name$
{
    $enum.Members:generateEnumMember(); separator=",\n"$
}
>>

generateEnumMember(member) ::= <<
$member.Name$ = $member.Value$
>>

generateStruct(struct, typeMap) ::= <<
public class $struct.Name$ : TBase
{
$if(struct.OptionalFields)$
    private IsSetInfo isSet;
$endif$
    $struct.Fields:generateBackingField(); separator="\n"$

$if(struct.OptionalFields)$
    /// <summary>
    /// Gets information about whether each optional field has been set.
    /// </summary>
    public IsSetInfo IsSet
    {
        get { return this.isSet; }
    }

$endif$
    $struct.Fields:generateField(); separator="\n\n"$

    /// <inheritdoc />
    public async Task ReadAsync(TProtocol protocol, CancellationToken cancellationToken)
    {
        protocol.IncrementRecursionDepth();

        try
        {
            await protocol.ReadStructBeginAsync(cancellationToken);
        
            while (true)
            {
                var field = await protocol.ReadFieldBeginAsync(cancellationToken);
                if (field.Type == TType.Stop)
                {
                    break;
                }

                switch (field.ID)
                {
                    $struct.Fields:{field | $generateReadFieldCaseStatement(field, typeMap)$}; separator="\n\n"$

                    default: 
                        await TProtocolUtil.SkipAsync(protocol, field.Type, cancellationToken);

                        break;
                }

                await protocol.ReadFieldEndAsync(cancellationToken);
            }

            await protocol.ReadStructEndAsync(cancellationToken);
        }
        finally
        {
            protocol.DecrementRecursionDepth();
        }
    }

    /// <inheritdoc />
    public async Task WriteAsync(TProtocol protocol, CancellationToken cancellationToken)
    {
        protocol.IncrementRecursionDepth();

        try
        {
            var @struct = new TStruct("$struct.Name$");
            await protocol.WriteStructBeginAsync(@struct, cancellationToken);

            var field = new TField();

            $struct.Fields:{field | $generateWriteField(field, typeMap)$}; separator="\n\n"$
      
            await protocol.WriteFieldStopAsync(cancellationToken);
            await protocol.WriteStructEndAsync(cancellationToken);
        }
        finally
        {
            protocol.DecrementRecursionDepth();
        }
    }

    /// <summary>
    /// Contains the Thrift Ids of all of the fields for use during serialization
    /// and deserialization.
    /// </summary>
    public static class FieldIds
    {
        $struct.Fields:generateFieldId(); separator="\n\n"$
    }
$if(struct.OptionalFields)$

    /// <summary>
    /// Contains an entry for each optional field, indicating whether it has been
    /// set or not.
    /// </summary>
    public struct IsSetInfo
    {
        $struct.OptionalFields:generateIsSetField(); separator="\n\n"$
    }
$endif$
}
>>

backingFieldName(field) ::= <<
_$field.Name$
>>

generateBackingField(field) ::= <<
private $field.Type.CSharpTypeName$ $backingFieldName(field)$;
>>

generateField(field) ::= <<
public $field.Type.CSharpTypeName$ $field.Name$
{
    get
    {
        return $backingFieldName(field)$;
    }

    set
    {
        this.$backingFieldName(field)$ = value;
        this.isSet.$field.Name$ = true;
    }
}
>>

generateFieldId(field) ::= <<
public const int $field.Name$ = $field.FieldId$;
>>

generateIsSetField(field) ::= <<
public bool $field.Name$;
>>

generateReadFieldCaseStatement(field, typeMap) ::= <<
case FieldIds.$field.Name$:
$if(field.Type.IsBaseType)$
    if (field.Type == $typeMap.(field.Type.Name).TypeName$)
    {
        this.$field.Name$ = await protocol.$typeMap.(field.Type.Name).ReadMethodName$(cancellationToken);
    }
$elseif(field.Type.IsEnum)$
    if (field.Type == TType.I32)
    {
        this.$field.Name$ = ($field.Type.CSharpTypeName$)await protocol.ReadI32Async(cancellationToken);
    }
$else$
    if (field.Type == TType.Struct)
    {
        this.$field.Name$ = new $field.Type.CSharpTypeName$();
        await this.$field.Name$.ReadAsync(protocol, cancellationToken);
    }
$endif$
    else
    {
        await TProtocolUtil.SkipAsync(protocol, field.Type, cancellationToken);
    }
    
    break;
>>

generateWriteField(field, typeMap) ::= <<
if (this.$field.Name$ != null && this.IsSet.$field.Name$)
{
    field.Name = "$field.Name$";
    field.ID = FieldIds.$field.Name$;
$if(field.Type.IsBaseType)$
    field.Type = $typeMap.(field.Type.Name).TypeName$;
$elseif(field.Type.IsEnum)$
    field.Type = TType.I32;
$else$
    field.Type = TType.Struct;
$endif$

    await protocol.WriteFieldBeginAsync(field, cancellationToken);
$if(field.Type.IsBaseType)$
    await protocol.$typeMap.(field.Type.Name).WriteMethodName$(this.$field.Name$ ?? default, cancellationToken);
$elseif(field.Type.IsEnum)$
    await protocol.WriteI32Async((int)this.$field.Name$, cancellationToken);
$else$
    await this.$field.Name$.WriteAsync(protocol, cancellationToken);
$endif$
    await protocol.WriteFieldEndAsync(cancellationToken);
}
>>
